'''
 SPDX-License-Identifier: Apache-2.0
 Copyright 2019 Western Digital Corporation or its affiliates.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 
 http:www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
'''

#### scons custom arguments ####
tagretName = ARGUMENTS.get('target', '')

#downloadFlag = ARGUMENTS.get('download', '0')

# set imports and variables of sconstruct
import sys
import os
import time
import utils
from demos.factory import generate

# generate the demo factory and set the demo 
objFactory = generate()
objDemo = objFactory.setDemo()

# set the output files for the demo
objDemo.set_outputfiles_names(prefix=tagretName)

root_dir = os.path.join(os.getcwd(),"..", "..")

listSupportedBoards = ['hifive1', 'hifive-un', 'nexys_a7_swerv1']
dependency_list = ['libftdi1-2',]

#### scons verbose #####
verbose = True

tc_root_env_var_name = 'RISCV_TC_ROOT'
tc_root_path = os.getenv(tc_root_env_var_name)
# check if the TC environment variable is set or empty
if not tc_root_path:
  print ("Set environment variable '" + tc_root_env_var_name + "' to point to the RISCV toolchain root")
  exit(1)
  
utils.check_installed_dependencis(dependency_list)

# set global environment

# path to scons toolchain scripts
Env = Environment(toolpath = ['toolchain'])

#def download(target, source, env):
#   print repr(source)
#   return None

#Env['BUILDERS']['Download'] = Builder(action = download)

# path to the RV toolchain 'bin' directory
Env['TOOLS_BASE_DIR'] = os.path.join(tc_root_path, 'bin')

# Tool c compiler execution
Env['CC_BIN'] = "riscv64-unknown-elf-gcc"
# Tool assembler compiler execution
Env['AS_BIN'] = "riscv64-unknown-elf-gcc"
# Tool archiver execution
Env['AR_BIN'] = "riscv64-unknown-elf-ar"
# Tool archiver execution
Env['RANLIB_BIN'] = "riscv64-unknown-elf-ranlib"

Env.Tool('as_rv')
Env.Tool('cc_rv')
Env.Tool('ar_rv')



# set output file suffixes
Env['OBJSUFFIX'] = '.o'
Env['LIBSUFFIX'] = '.a'
Env['PROGSUFFIX'] = '.elf'

Env['ROOT_DIR']        = root_dir
Env['BSP_DEF']         = []
Env['RTOSAL_DEF']      = []
Env['RTOSAL_INC_PATH'] = []
Env['RTOS_INC_PATH']   = []
Env['BSP_INC_PATH']    = []
Env['TARGET_LIBS']     = []
Env['RTOS_CORE']       = []
Env['PUBLIC_INC_PATH'] = []
Env['PUBLIC_DEF']      = [] 
Env['OUT_DIR_PATH']    = 'output'
Env['TARGET_BOARD']    = tagretName
Env['EXAMPLE_NAME']    = objDemo.name

Env['MAP_FILE'] = os.path.join(Env['OUT_DIR_PATH'], objDemo.map_file)

cc_options = ['-mabi=ilp32', '-g3', '-gdwarf-2', '-march=rv32imac', '-mcmodel=medany']
Env['C_FLAGS'] = ['-Os', '-ffunction-sections','-fdata-sections','-Wall','-c','-fno-builtin-printf','-include', 'sys/cdefs.h'] + cc_options
Env['A_FLAGS'] = ['-Wall', '-c', '-Wa,-march=rv32imac', '-x', 'assembler-with-cpp'] + cc_options

if verbose == False:
  # set output to minimal mode
  Env['CCCOMSTR'] = 'Compiling $SOURCES'
  Env['LINKCOMSTR'] = 'Linking $TARGET'
  Env['ASCOMSTR'] = 'Compiling $SOURCES'
  Env['ARCOMSTR'] = 'Archiving $TARGET'

# to solve long command line problems (in win32)
#SetupSpawn(Env)

# for debug
#print Env.Dump()

utils.createFolder(Env['OUT_DIR_PATH'])

# linker flags
Env['LINKFLAGS'] = ['-nostartfiles', '-static', '-nostdlib',  '-Wl,--wrap=malloc', '-Wl,--wrap=free', '-Wl,--wrap=open', '-Wl,--wrap=lseek', 
                    '-Wl,--wrap=read', '-Wl,--wrap=write', '-Wl,--wrap=fstat', '-Wl,--wrap=stat', '-Wl,--wrap=close', 
                    '-Wl,--wrap=link', '-Wl,--wrap=unlink', '-Wl,--wrap=execve', '-Wl,--wrap=fork', '-Wl,--wrap=getpid', '-Wl,--wrap=kill', 
                    '-Wl,--wrap=wait', '-Wl,--wrap=isatty',  '-Wl,--wrap=times', '-Wl,--wrap=sbrk', '-Wl,--wrap=_exit', '-L.', 
                    '-Wl,--start-group', '-Wl,--end-group', '-Wl,-gc-sections', '-Wl,--start-group',
                    '-Wl,-Map='+ Env['MAP_FILE'] ] + cc_options

#, LIBPATH='.'

if Env['TARGET_BOARD'] not in listSupportedBoards:
  print "missing target=%s" % " | ".join(listSupportedBoards)
  exit(1)

Env['BUILDERS']['Size'] = Builder(action = utils.produce_sections_size)
#Env['RTOS_CORE'] = objDemo.rtos_core
Env['RTOSAL_DEF'] = objDemo.rtos_defines
Env['PUBLIC_DEF'] = objDemo.public_defs
Env['TARGET_LIBS'] += ['c', 'gcc']

if objDemo.name == 'ex_freertos':
  if Env['TARGET_BOARD'] == 'nexys_a7_swerv1':
    Env['PUBLIC_DEF'].append('D_NEXYS_A7')
  elif Env['TARGET_BOARD'] == 'hifive1':
    Env['PUBLIC_DEF'].append('D_HI_FIVE1')

arr_lib = []
arr_lib.append(SConscript('SConscript_bsp_'+ Env['TARGET_BOARD'], exports='Env'))

for strModule in objDemo.moduls:
  arr_lib.append(SConscript('SConscript_%s' % strModule, exports='Env'))

elf_file_name = os.path.join(Env['OUT_DIR_PATH'], objDemo.elf_file)
example_bundle = Env.Program(elf_file_name, arr_lib, LIBS=Env['TARGET_LIBS'])
Env.Size(source=example_bundle)

#append to the map file the   
#if downloadFlag != '0':
#  Env.Download(source=example_bundle)
